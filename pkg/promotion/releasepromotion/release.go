package releasepromotion

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"

	cioperatorapi "github.com/openshift/ci-tools/pkg/api"
	"github.com/openshift/ci-tools/pkg/config"
	"k8s.io/apimachinery/pkg/util/sets"
)

// Verifier verifies that a set of ci-operator job definitions have unique image promotions
// and allows generation of standard files that can be approved for changes for the images
// that are promoted. It also can generate mirroring jobs.
type Verifier struct {
	targets verifierMap
	errs    []error
}

// NewVerifer constructs a promotion and mirroring verifier.
func NewVerifier() *Verifier {
	return &Verifier{
		targets: make(verifierMap),
	}
}

// Errors returns all errors the verifier has detected.
func (v *Verifier) Errors() []error {
	return v.errs
}

// LoadConfig processes a single ci-operator configuration and returns an error if the config could not
// be processed. Verification errors are added for later retrieval by Errors().
func (v *Verifier) LoadConfig(config *cioperatorapi.ReleaseBuildConfiguration, info *config.Info) error {
	p := config.PromotionConfiguration
	if p == nil || p.Disabled {
		return nil
	}
	excluded, included := sets.NewString(p.ExcludedImages...), sets.NewString()
	key := promotionTarget{Namespace: p.Namespace, Name: p.Name, NamePrefix: p.NamePrefix, Tag: p.Tag}
	if key.Empty() {
		v.errs = append(v.errs, fmt.Errorf("%s: promotion target is empty", info.Filename))
		return nil
	}
	target := v.targets.get(key)
	for i := range config.Images {
		if err := target.addStep(&config.Images[i], config.Images[i].Optional, excluded, included, info, key); err != nil {
			v.errs = append(v.errs, fmt.Errorf("%s: %v", info.Filename, err))
			return nil
		}
	}
	for _, step := range config.RawSteps {
		if err := target.addStep(step.ProjectDirectoryImageBuildStepConfiguration, true, excluded, included, info, key); err != nil {
			v.errs = append(v.errs, fmt.Errorf("%s: %v", info.Filename, err))
			return nil
		}
	}
	for to, from := range p.AdditionalImages {
		if err := target.addReference(from, to, included, info, key); err != nil {
			v.errs = append(v.errs, fmt.Errorf("%s: %v", info.Filename, err))
			return nil
		}
	}
	return nil
}

// WriteImages generates images.txt for all targets in the verifier that allows easy review of the
// result of adding a new promoted image. This allows reviewers and approvers to make sure naming
// follows consistent rules within a release.
func (v *Verifier) WriteImages(toDir, commandName string) error {
	// remove any old names under this directory
	if err := filepath.Walk(toDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			return nil
		}
		if name := info.Name(); name == "images.txt" {
			return os.Remove(path)
		}
		return nil
	}); err != nil && !os.IsNotExist(err) {
		return err
	}
	// add names back
	for key, target := range v.targets {
		base := filepath.Join(append([]string{toDir}, key.Directory()...)...)
		if err := os.MkdirAll(base, 0755); err != nil {
			return err
		}
		keys := sets.NewString()
		for name := range target {
			keys.Insert(name)
		}
		buf := &bytes.Buffer{}
		fmt.Fprintf(buf, "# generated by %s, do not edit\n", commandName)

		for _, name := range keys.List() {
			src := target[name].info
			fmt.Fprintf(buf, "%s from %s promotes to %s\n", name, src.RelativePath(), key.String())
		}
		if err := ioutil.WriteFile(filepath.Join(base, "images.txt"), buf.Bytes(), 0640); err != nil {
			return err
		}
	}
	return nil
}

type verifierMap map[promotionTarget]promotionNames

func (m verifierMap) get(key promotionTarget) promotionNames {
	v, ok := m[key]
	if ok {
		return v
	}
	v = make(promotionNames)
	m[key] = v
	return v
}

type promotionTarget struct {
	Namespace  string
	Name       string
	NamePrefix string
	Tag        string
}

func (t promotionTarget) Empty() bool {
	return len(t.Namespace) == 0 || (len(t.Name) == 0 && len(t.NamePrefix) == 0 && len(t.Tag) == 0)
}

func (t promotionTarget) String() string {
	if len(t.NamePrefix) > 0 {
		return fmt.Sprintf("%s/%s{image}:%s", t.Namespace, t.NamePrefix, t.Tag)
	}
	if len(t.Name) > 0 {
		return fmt.Sprintf("%s/%s:{image}", t.Namespace, t.Name)
	}
	return fmt.Sprintf("%s/{image}:%s", t.Namespace, t.Tag)
}

func (t promotionTarget) Directory() []string {
	if len(t.NamePrefix) > 0 {
		return []string{t.Namespace, t.NamePrefix, t.Tag}
	}
	if len(t.Name) > 0 {
		return []string{t.Namespace, t.Name}
	}
	return []string{t.Namespace, "tag", t.Tag}
}

func (t promotionTarget) PullSpec() string {
	return fmt.Sprintf("{registry}/%s", t.String())
}

type promotionNames map[string]promotionSource

func (m promotionNames) addReference(from, to string, included sets.String, info *config.Info, target promotionTarget) error {
	if !included.Has(from) && from != "src" && from != "rpms" {
		return fmt.Errorf("promotes an image %q that is not built with via a project directory image build step or rpm step", from)
	}
	if included.Has(to) && from == to {
		return nil
	}
	source := promotionSource{info: info}
	if existing, ok := m[to]; ok {
		return fmt.Errorf("%s is already promoting an image named %q to %s", existing.info.Filename, from, target)
	}
	m[to] = source
	return nil
}

func (m promotionNames) addStep(image *cioperatorapi.ProjectDirectoryImageBuildStepConfiguration, optional bool, excluded, included sets.String, info *config.Info, target promotionTarget) error {
	if image == nil {
		return nil
	}
	name := string(image.To)
	if len(name) == 0 {
		return nil
	}
	if _, ok := included[string(name)]; ok {
		return fmt.Errorf("defines image %q more than once", name)
	}
	if excluded.Has(name) {
		return nil
	}
	included.Insert(name)
	if optional {
		return nil
	}
	source := promotionSource{info: info}
	if existing, ok := m[name]; ok {
		return fmt.Errorf("%s is already promoting an image named %q to %s", existing.info.Filename, name, target)
	}
	m[name] = source
	return nil
}

type promotionSource struct {
	info *config.Info
}
