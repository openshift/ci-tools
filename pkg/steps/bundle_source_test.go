package steps

import (
	"bytes"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"testing"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	fakectrlruntimeclient "sigs.k8s.io/controller-runtime/pkg/client/fake"

	imagev1 "github.com/openshift/api/image/v1"

	"github.com/openshift/ci-tools/pkg/api"
	"github.com/openshift/ci-tools/pkg/steps/loggingclient"
)

var subs = []api.PullSpecSubstitution{
	{
		PullSpec: "quay.io/openshift/origin-metering-ansible-operator:4.6",
		With:     "pipeline:metering-ansible-operator",
	},
	{
		PullSpec: "quay.io/openshift/origin-metering-reporting-operator:4.6",
		With:     "pipeline:metering-reporting-operator",
	},
	{
		PullSpec: "quay.io/openshift/origin-metering-presto:4.6",
		With:     "stable:metering-presto",
	},
	{
		PullSpec: "quay.io/openshift/origin-metering-hive:4.6",
		With:     "stable:metering-hive",
	},
	{
		PullSpec: "quay.io/openshift/origin-metering-hadoop:4.6",
		With:     "stable:metering-hadoop",
	},
	{
		PullSpec: "quay.io/openshift/origin-ghostunnel:4.6",
		With:     "stable:ghostunnel",
	},
}

func TestReplaceCommand(t *testing.T) {
	if runtime.GOOS != "linux" {
		t.Skipf("skipping test on %s OS", runtime.GOOS)
	}
	temp := t.TempDir()
	if err := exec.Command("cp", "-a", "testdata/4.6", temp).Run(); err != nil {
		t.Fatalf("Failed to copy testdata to tempdir: %v", err)
	}
	for _, sub := range subs {
		// the dockerfile generated by ImageDigestFor uses exact image tag substitution, which uses @sha as the suffix
		// substitute the `:` with a `@` to verify the sed command works with it
		replace := replaceCommand(sub.PullSpec, strings.Replace(sub.With, ":", "@", 1))
		// docker runs commands using `/bin/sh -c givenCommand`, so we do the same to test here
		cmd := exec.Command("/bin/sh", "-c", replace)
		cmd.Dir = temp
		if err := cmd.Run(); err != nil {
			t.Fatalf("Failed to run replace command  \"%s\": %v", replaceCommand(sub.PullSpec, sub.With), err)
		}
	}
	files, err := os.ReadDir(filepath.Join(temp, "4.6"))
	if err != nil {
		t.Fatalf("Failed to read directory: %v", err)
	}
	for _, file := range files {
		updatedFilename := filepath.Join(temp, "4.6", file.Name())
		updated, err := os.ReadFile(updatedFilename)
		if err != nil {
			t.Fatalf("Failed to read file %s: %v", updatedFilename, err)
		}
		expectedFilename := filepath.Join("testdata/4.6-expected", file.Name())
		expected, err := os.ReadFile(expectedFilename)
		if err != nil {
			t.Fatalf("Failed to read file %s: %v", expectedFilename, err)
		}
		if !bytes.Equal(updated, expected) {
			t.Errorf("Updated file %s not equal to expected file %s;\nValue of updated file: %s", updatedFilename, expectedFilename, string(updated))
		}
	}
}

func TestBundleSourceDockerfile(t *testing.T) {
	var expectedDockerfile = `FROM pipeline:src
RUN find . -type f -regex ".*\.\(yaml\|yml\)" -exec sed -i s?quay.io/openshift/origin-metering-ansible-operator:4.6?some-reg/target-namespace/pipeline@metering-ansible-operator?g {} +
RUN find . -type f -regex ".*\.\(yaml\|yml\)" -exec sed -i s?quay.io/openshift/origin-metering-reporting-operator:4.6?some-reg/target-namespace/pipeline@metering-reporting-operator?g {} +
RUN find . -type f -regex ".*\.\(yaml\|yml\)" -exec sed -i s?quay.io/openshift/origin-metering-presto:4.6?some-reg/target-namespace/stable@metering-presto?g {} +
RUN find . -type f -regex ".*\.\(yaml\|yml\)" -exec sed -i s?quay.io/openshift/origin-metering-hive:4.6?some-reg/target-namespace/stable@metering-hive?g {} +
RUN find . -type f -regex ".*\.\(yaml\|yml\)" -exec sed -i s?quay.io/openshift/origin-metering-hadoop:4.6?some-reg/target-namespace/stable@metering-hadoop?g {} +
RUN find . -type f -regex ".*\.\(yaml\|yml\)" -exec sed -i s?quay.io/openshift/origin-ghostunnel:4.6?some-reg/target-namespace/stable@ghostunnel?g {} +`

	client := &buildClient{LoggingClient: loggingclient.New(fakectrlruntimeclient.NewClientBuilder().WithRuntimeObjects(
		&imagev1.ImageStream{
			ObjectMeta: metav1.ObjectMeta{
				Namespace: "target-namespace",
				Name:      api.StableImageStream,
			},
			Status: imagev1.ImageStreamStatus{
				PublicDockerImageRepository: "some-reg/target-namespace/stable",
				Tags: []imagev1.NamedTagEventList{{
					Tag: "metering-presto",
					Items: []imagev1.TagEvent{{
						Image: "metering-presto",
					}},
				}, {
					Tag: "metering-hive",
					Items: []imagev1.TagEvent{{
						Image: "metering-hive",
					}},
				}, {
					Tag: "metering-hadoop",
					Items: []imagev1.TagEvent{{
						Image: "metering-hadoop",
					}},
				}, {
					Tag: "ghostunnel",
					Items: []imagev1.TagEvent{{
						Image: "ghostunnel",
					}},
				}},
			},
		},
		&imagev1.ImageStream{
			ObjectMeta: metav1.ObjectMeta{
				Namespace: "target-namespace",
				Name:      api.PipelineImageStream,
			},
			Status: imagev1.ImageStreamStatus{
				PublicDockerImageRepository: "some-reg/target-namespace/pipeline",
				Tags: []imagev1.NamedTagEventList{{
					Tag: "metering-ansible-operator",
					Items: []imagev1.TagEvent{{
						Image: "metering-ansible-operator",
					}},
				}, {
					Tag: "metering-reporting-operator",
					Items: []imagev1.TagEvent{{
						Image: "metering-reporting-operator",
					}},
				}},
			},
		}).Build(), nil),
	}

	s := bundleSourceStep{
		config: api.BundleSourceStepConfiguration{
			Substitutions: subs,
		},
		jobSpec: &api.JobSpec{},
		client:  client,
	}
	s.jobSpec.SetNamespace("target-namespace")
	generatedDockerfile, err := s.bundleSourceDockerfile()
	if err != nil {
		t.Fatalf("Unexpected error: %v", err)
	}
	if expectedDockerfile != generatedDockerfile {
		t.Errorf("Generated bundle source dockerfile does not equal expected; generated dockerfile: %s", generatedDockerfile)
	}
}
